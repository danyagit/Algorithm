newcoder：
12. 矩阵中的路径 和backtracking里面 3. 在字符矩阵中寻找字符串一样  dfs
13. 机器人的运动范围 dfs
38. 字符串的排列 backtracking排列组合

leetcode
BFS:
1. 计算在网格中从原点到特定点的最短路径长度
3. 最短单词路径，单词接龙
总结BFS方法
 * 广度优先搜索就是为了找出图的最短路径
 * 主要步骤：
 * 1、queue加入第一个节点，并在标记数组中作出标记（我这里标记数组，0表示没有走过，其他数字表示走的第几步）
 * 2、以queue不为空作为循环条件循环
 * 		弹出queue的元素，并将此元素作为父元素，寻找下一个可能的元素，
 * 筛选出能走的节点（判断条件很关键）。下一个可能的元素可能有很多个，可以把它放到一个ArrayList中。
 * 同时，不能忘记将能走的节点进行标记。
 * 3、遍历ArrayList获取每一个能走的节点，能走的节点里面如果有最终节点，就返回它对应标记数组的值
tips：BFS用不到递归

DFS：
1. 查找最大的连通面积
整体的框架：
主函数：
从头遍历岛屿数组{
	如果当前元素为1&&没有被标记过{
		寻找此处岛屿的最大联通面积
	}
}
//递归函数：寻找寻找某处岛屿的最大联通面积
{
	做好连通面积的统计，并且将他们都标记为已经走过的。
}
2. 矩阵中的连通分量数目
和上题差不多
3. 好友关系的连通分量数目，求朋友圈的个数
这题有一点区别就是：看起来是一个二维矩阵的问题，但实际上是个一维问题，标记数组只需要是一个一维的数组即可，
当标记数组标记完了，就结束了。
整体框架：
主函数：
遍历一维标记数组{
	如果当前同学没有标记{
		标记他的所有朋友
		朋友圈++;
	}
}
递归函数：
标记某个同学及其所有朋友

4. 填充封闭区域，题目描述：使被 'X' 包围的 'O' 转换为 'X'。围棋
此题可以从四条边出发，对每个为O的进行深度搜索并标记（类似于查找最大连通面积那题），
标记了的就说明不是被X围起来的，就不用替换。

5. 能到达太平洋和大西洋的区域
分析：
能到达太平洋的岛屿必定最终是从上、左两条边出去的。
那么就沿着这两条边进行深度搜索，搜索出来的元素都能到达太平洋。
同理也可以用另一个标记数组标记处所有能到达大西洋的元素。
取交集。 

关于BFS和DFS：主要是做图的题目。
BFS一般是图的最短路径，不需要用到递归。
DFS一般是需要用到递归，找到一个就找到和它关联的所有。                        
二者一般都需要标记数组。













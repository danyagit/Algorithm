难点

newcoder：
16. 数值的整数次方
我的做法：看代码，普通做法
分治做法：时间复杂度logN
private double pow(double x, int n) {
    if (n == 0) return 1;
    if (n == 1) return x;
    double res = pow(x, n / 2);
    res = res * res;
    if (n % 2 != 0) res *= x;
    return res;
}

leetcode:
1. 给表达式加括号（难）
思想：
分解：按运算符分成左右两部分，分别求解
解决：实现一个递归函数，输入算式，返回算式解。左右两部分各返回一个解
合并：根据运算符合并左右两部分的解，得出最终解
总结：分治都用到了递归。
2. 给定一个数字 n，要求生成所有值为 1...n 的二叉搜索树。
和上一题类似
以某节点为根节点，其左边的作为左子树的元素，右边作为右子树节点。
那么可以看出左右两边各自又可以生成很多种二叉搜索树，也是用list来装这么多的情况。
显然这是一个递归的过程，两边的各种情况也要排列组合。
因为每次递归的过程中，左右区间是变化的，所以可以确定递归变量为generate(int left,int right)。


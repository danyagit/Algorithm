leetcode:

1. 数字键盘组合
是个纯排列组合问题，使用回溯法，回溯法是递归方法，它包含一个剪枝的过程
该backtracking方法框架
递归参数：当前拼凑字符串、存放结果的list、输入digits
{
	1、递归终止条件：当前拼凑字符串长度等于digits长度；
	2、遍历当前需要排列组合的那三个字母（可以通过当前拼凑字符串长度拿到）：
		在当前拼凑字符串后拼凑上字母
		递归函数
		在当前拼凑字符串后去掉字母
}

可见，该方法中递归参数里面，当前拼凑字符串是必不可少的，
因为每次递归它都会变化，而其他两个参数可以用全局变量替换。

2. IP 地址划分，按照合法的方式复原IP地址
我的做法：按照纯排列组合的方式去做的（类似于上题），但最终添加到结果list里面的有的还不是合法IP，因此还要做二次筛选。
参考答案做法实现了添加的字符串全都是合法的，而且时间复杂度提升了很多。 

重做！！！

3. 在字符矩阵中寻找字符串
这题是个二维图的搜索过程啊，连通问题。可以使用前面的dfs方法实现。
整体框架：
主函数：
	遍历二维矩阵，以每个元素为起点，判断

递归函数：判断当前点为起点，是否能找到所求字符串
	递归参数：矩阵坐标（i,j表示当前在矩阵的哪个位置）、标记数组、当前长度、目标字符串、
	递归终止条件：当前拼凑的长度和所求字符串相等，返回true
				  当前字符和矩阵当前位置的字符不一样，返回false
				  当前字符已经标记过，返回false
	标记当前位置；
	对邻近四个点分别进行递归，如果有一个true就返回true；
	如果这四个点都不行，就取消标记当前点（如果不取消，以后这个点就用不了了）。//这也是一个剪枝的过程，只不过要判断什么时候要剪枝

重做！！！！

4. 输出二叉树中所有从根到叶子的路径 1->2->3
此题就不一一写步骤了，需要注意的点是
1、可以使用一个list来存储当前的接点，不要一开始就连接
2、剪枝的时候要注意：
递归保存左节点
判断左节点是否为空，不为空则说明list中确实会保存，剪枝
递归保存右节点
判断右节点是否为空，不为空则说明list中确实会保存，剪枝

总结：剪枝一般发生在递归那一行之后，树的剪枝一般需要两次（因为需要两次递归）

5. 排列，纯排列组合
不说了

6. 含有相同元素排列组合
采用了暴力法，在上一题的基础上，最后再排除相同的

很慢，重写！！

7. 组合
不说了

8. 组合求和
这题不应该是个背包问题吗

9. 含有相同元素的组合求和
这题不应该是个背包问题吗

10. 1-9 数字的组合求和
这题不应该是个背包问题吗

11. 子集
实际上也是排列组合问题，技巧是分不同长度来寻找子集
12. 含有相同元素求子集

13. 分割字符串使得每个部分都是回文数
也是排列组合问题


总结：backtracking方法主要就是用于排列组合：排列组合问题、组合求和问题、二叉树问题
主要问题集中于时间复杂度这一块，比如一些条件判断退出循环可以减少时间复杂度。
再做一下这些题和答案对比，看看问题在哪里。





